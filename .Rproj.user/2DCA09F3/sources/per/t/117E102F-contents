#' group I intron scanning tool
#' 
#' @author Rainer Machne
#' @docType package
#' @name cmchainer
#' @section Dependencies: The package uses mostly functionality from base R,
#' (graphics, grDevices, stats, utils)
#' 
#' @importFrom grDevices colors dev.cur gray rgb xy.coords
#' @importFrom graphics arrows axis image legend lines par plot points polygon text
#' @importFrom stats na.omit
#' @importFrom utils read.csv read.table
NULL

## FUNCTIONS FOR RNA SECONDARY STRUCTURE MANIPULATION
## used in scripts at $TATADIR/introns/scripts


#' return WUSL basepair notation
#' 
#' @param type type to return, either "pairs" for all base pairs,
#' "open" for opening half, "close" for closing half, or "single"
#' for unpaired basepairs
#' 
#' @export
wusl <- function(type=c("pairs","open","close","single")) {
    pairs <- c("(","<","[","{","}","]",">",")")
    singles <- c(".",",",":","-","_")
    if ( type[1]=="open" ) pairs <- pairs[1:4]
    if ( type[1]=="close" ) pairs <- pairs[5:8]
    if ( type[1]=="single" ) pairs <- singles
    pairs
}

#' convert WUSL to dot-bracket notation
#'
#' @param wusl WUSL secondary structure string
#'
#' @return dot-bracket secondary structure string
#' @export
#'
#' @examples
#' wusl2dtb("<<<____>>>:::")
wusl2dtb <- function(wusl) {
  open <- c("<","\\[","\\{")
  close <- c("\\}","\\]",">")
  single <- c(",",":","-","_")
  dtb <- wusl
  for ( op in open ) dtb <- gsub(op,"(",dtb)
  for ( cl in close ) dtb <- gsub(cl,")",dtb)
  for ( sl in single ) dtb <- gsub(sl,".",dtb)
  dtb
}

#' t->u, T->U in a string
#'
#' @param seq a DNA sequence string
#' 
#' @export
#' 
#' @examples 
#' dna2rna("AGTCagtc")
dna2rna <- function(seq) {
  paste(sub("T","U",sub("t","u",unlist(strsplit(seq,"")))),collapse="")
}
#' convert DNA to RNA sequences (T->U) in all sequences of a readFASTA object
#' @param fst a sequence object as returned by \code{\link{readFASTA}}
#'@export
fst2rna <- function(fst) {
  lapply(fst, function(x) {x$seq <-dna2rna(x$seq);x})
}


## 
#' convert secondary structure to dot-plot matrix
#'
#' @param ss dot-bracket secondary structure vector
#'
#' @return a dot-plot matrix
#' @export
#'
#' @examples
#' ss2dotplot(unlist(strsplit(".((..)).","")))
ss2dotplot <- function(ss) {

  pairs <- ss2bp(ss)$pairs
  ## bp matrix
  bpmat <- matrix(0,nrow=length(ss),ncol=length(ss))
  for ( i in 1:nrow(pairs) ) {
    bpmat[pairs[i,1],pairs[i,2]] <- 1
  }
  bpmat <-bpmat+t(bpmat)
  closure <- matrix(0, nrow=nrow(pairs), ncol=nrow(pairs))
  for ( i in 1:nrow(pairs) ) {
    closure[,i] <- as.numeric(pairs[i,2] > pairs[,2])
  }
  bpmat
}

#' invert pseudoknots in WUSL notation
#'
#' get a secondary structure annotation in WUSL format, and inlcuding
#' a pseudo-knot annotation AAA aaa; return two ss. strings
#' were one half of  the pk is resolved
#' @param ss WUSL secondary structure vector with pseudoknot
#' @param b bracket notation for base pairs
#'
#' @return dot-bracket
#' @export
#'
#' @examples
#' str <- "((.(()).AA.)).((..aa..))"
#' paste(invertpk(ss = unlist(strsplit(str,"")), b="()"),collapse="")
invertpk<-function(ss, b="()") {

  br <- unlist(strsplit(b,""))
  bp <- ss2bp(ss,verb=FALSE)
  ss[bp$pk$pkpairs[,1]] <- br[1]
  ss[bp$pk$pkpairs[,2]] <- br[2]
  ss[bp$pk$lpkpairs[,1]] <- "A"
  ss[bp$pk$lpkpairs[,2]] <- "a"
  ss[bp$pk$rpkpairs[,1]] <- "B"
  ss[bp$pk$rpkpairs[,2]] <- "b"
  ss
}

#' convert RNA secondary structure character vector to list of basepairs
#' 
#' convert RNA secondary structure in dot-bracket notation to
#' an enumerated list of pairs pais, including enumerations of
#' hairpin stems and loops. TODO: start from string instead of vector!
#' @param ss a vector of characters providing RNA secondary structure
#' in dot-bracket notation
#' @param verb verbose output if TRUE
#'@export
ss2bp <- function(ss= unlist(strsplit("(((())(())))(())","")),verb=FALSE) {
  ## first, find ij basepairs
  stack <- NULL
  pairs <- NULL
  stem <- 0
  closing <- FALSE
  ## type of basepair: 0=single or basis of loop, 1=stem, 2= basis of multiloop
  typcnt <- rep(0,length(ss))
  ## loop sizes (and TODO: types)
  lopcnt <- loptyp <- typcnt
  ## joining region sizes
  joincnt <- typcnt
  jcnt <- 0
  ## for pseudoknots
  pkstack <- NULL
  pkpairs <- NULL
  lpkstack <- NULL ## left conflicting pairs
  lpkpairs <- NULL
  rpkstack <- NULL ## right conflicting pairs
  rpkpairs <- NULL
  pkstem <- 0
  pkclosing <- FALSE
  pkopen <- FALSE
  ## stem counts
  stmcnt <- pkstmcnt <- typcnt
  last <- 0
  for ( j in 1:length(ss) ) {
    if ( verb ) cat(paste("base #", j))

    if ( ss[j] %in% wusl("open") ) { ## OPENING
    
      if ( length(stack)==0 ) {
        if ( verb ) cat(paste("\tnew stem",stem))
        stem <- stem+1
      } else if ( closing ) {
        if ( verb ) cat(paste("\tnew internal stem",stem))
        stem <- stem +1
      }
      ## add to stack
      push(stack,j)
      closing <- FALSE

      ## PK, add to right-conflicting pairs
      if ( pkopen ) push(rpkstack, j)

      ## JOINING REGIONS
      joincnt[j] <- jcnt
      jcnt <- 0
      
    } else if ( ss[j] %in% wusl("close") ) {  ## CLOSING
      
      ## add to base pair list!
      i <- pop(stack)
      pairs <- rbind(pairs, c(i,j))
      closing <- TRUE
      ## TYPES
      ## 0: single or bp at basis of loop
      ## 1: bp, 2+: bp at the base of a multiloop with 2+ intermediate stems
      nxt <- stack[length(stack)]
      typcnt[nxt] <- typcnt[nxt]+1
      oldcnt <- typcnt[j]
      typcnt[j] <- typcnt[i]
      ## if the base of a multiloop was detected,
      ## increase the stem count, so the enclosing stem
      ## gets a new number!
      if ( typcnt[j]>1 & typcnt[j]>oldcnt ) stem <- stem+ typcnt[j]-1

      ## record stem number
      stmcnt[j] <- stmcnt[i] <- stem
      
      if ( verb ) cat(paste("\tbp", i,j, "closed"))
      if ( length(stack)==0 & verb ) cat(paste("\tstack empty"))

      ## PK, close left- & right-conflicting and PK internal pairs
      if ( pkopen & length(lpkstack)>0 ) {
        if ( i == lpkstack[length(lpkstack)] ) {     
          ik <- pop(lpkstack)
          lpkpairs <- rbind(lpkpairs, c(ik,j)) ## left-conflicting
          if ( verb ) cat(paste("\tLPK bp", ik,j, "closed"))
        }
      }
      if ( length(rpkstack)>0 ) {
        ik <- pop(rpkstack)
        if ( !pkopen )  {  ## right-conflicting
          rpkpairs <- rbind(rpkpairs, c(ik,j))          
          if ( verb ) cat(paste("\tRPK bp", ik,j, "closed"))
        }
      }
    } else if ( length(stack)== 0 ) { ## JOINING REGIONS
      jcnt <- jcnt + 1
    }

    ## LOOP SIZES
    ## count how long the current stack stays on top
    ## currently only assigns loops only to opening bases and
    ## e.g. adds the right side of two-sides internal bulges
    curr <- stack[length(stack)]
    if ( length(last)>0 & length(curr)>0 ) 
      lopcnt[curr] <- lopcnt[curr] + as.numeric(curr == last)
    last <- curr
    
  
    if ( ss[j] %in% toupper(letters) ) { ## OPENING PSEUDOKNOT
      ## types
      if ( length(pkstack)==0 ) {
        pkstem <- pkstem+1
        #stem <- stem+1 ## increase global stem count
        if ( verb ) cat(paste("\tnew PK stem",pkstem))
      } else if ( pkclosing ) {
        pkstem <- pkstem +1
        if ( verb ) cat(paste("\tnew internal PK stem",pkstem))
      }
      ## handle stacks
      if ( !pkopen ) lpkstack <- stack ## copy stack to left-conflicting pairs
      pkopen <- TRUE
      pkclosing <- FALSE
      push(pkstack,j)
    }
    
    if ( ss[j] %in% letters ) { ## CLOSING PSEUDOKNOT
      ## handle stacks
      if ( pkopen ) lpkstack <- NULL ## remove open multi-loops
      i <- pop(pkstack) ## get pair
      pkpairs <- rbind(pkpairs,c(i,j))
      ##if ( length(pkstack)==0 ) 
      pkopen <- FALSE  ## finished?
      pkclosing <- TRUE
      
      pkstmcnt[j] <- pkstmcnt[i] <- pkstem
      ## if finished, increase global stem count
      if ( length(pkstack)==0 )  stem <- stem+1
          
      if ( verb ) cat(paste("\tPSEUDO KNOT bp", i,j, "closed"))
    }   
    if ( verb ) cat("; ")
  }
  if ( verb ) cat("\n")
  pairs <- pairs[order(pairs[,1]),]

  ## re-label stem count
  ## TODO: account for pseudoknots in count, e.g., just
  ## relabel the stem-count from bp2tree
  cnt <- 1
  stemnum <- rep(0, nrow(pairs))
  for ( i in 1:(nrow(pairs)-1) ) {
    j <- i+1
    stemnum[i] <- cnt
    ## new stem: either next basepair j is not contained, or the current
    ## basepair is at the branch of a multiloop
    if ( !(pairs[i,1] < pairs[j,1] & pairs[i,2] > pairs[j,2]) )
      cnt <- cnt+1
    if ( typcnt[pairs[i,1]]>1 ) 
      cnt <- cnt+1
  }
  stemnum[nrow(pairs)] <- cnt
  
  #for ( i in 1:nrow(pairs) ) {
  #  
  #}
  
  ## assemble pseudoknot info
  pk <- NULL
  if ( !is.null(pkpairs) ) {
    pkpairs <- pkpairs[order(pkpairs[,1]),]
    if ( !is.null(lpkpairs) ) lpkpairs <- lpkpairs[order(lpkpairs[,1]),]
    if ( !is.null(rpkpairs) ) rpkpairs <- rpkpairs[order(rpkpairs[,1]),]
    pk <- list(pkpairs=pkpairs, lpkpairs=lpkpairs, rpkpairs=rpkpairs,
             pkstm=pkstmcnt)
  }
  
  singles <- which(! 1:length(ss) %in% c(pairs) )
  pairs <- cbind(i=pairs[,1], j=pairs[,2],stem=stemnum)
  list(singles=singles, pairs=pairs,
       type=typcnt, loop=lopcnt, join=joincnt, stem=stmcnt, pk=pk)
  
}

## UNFINISHED: convert secondary structure to tree

## DNA/RNA MOTIFS/PATTERNS
## mod. from Rob Lehmann in $TATADIR/cyanos/scripts/lehmann13_functions.R
#' finds a set of patterns in a sequence
#' 
#' finds a set of patterns (list of strings) in a sequence (character string)
#' and returns a vector of 0 and 1 of the same length as the sequence,
#' where 1 indicates presence of any of the patterns
#' in the sequence at this position. This can be used, eg., to indicate
#' positions of groups of dinucleotides (eg. all AA,TT,AT)
#' @param seq a string, the sequence in which patterns will be searched
#' @param patterns a list of strings, the patterns
#' @export
seqPattern <- function(seq, patterns) {
  pattern.pos <- lapply(patterns, function(x) unlist(gregexpr(x,seq)))
  ##add hits for patterns in sequence
  pat.pos <- rep(0,nchar(seq))
  for( i in 1:length(patterns) ) 
    pat.pos[ pattern.pos[[i]] ] <- 1
  pat.pos
} 


## COLLAPSER - used in chainer!
## takes coordinate files (parseHomHits) and collapses overlapping
## hits of the same type (optionally via a mapping of the column "model",
## and an ordering of models) into one hit, used e.g., in chainer!
#' merges hits of the same type ("model") if their genomic coordinates overlap
#'
#' @param hits a table of results from a genome scan with infernal for different
#' covariance models, specified in column "model"
#' @param mmap a named vector to map the hit models to model types, and hits
#' of the same type will be merged
#' @param mord model ordering
#' @param debug print debug messages if TRUE
#'@export
collapseHits <- function(hits, mmap, mord, debug=FALSE) {

  ## re-name hits by their common model type
  if ( !missing(mmap) ) {
    hits[,"model"] <- mmap[as.character(hits[,"model"])]
  }
  ## models can be ordered!
  if ( missing(mord) ) {
    mord <- sort(unique(hits[,"model"]))
  }
    
  ## order by midpoint on target (probably already ordered, but make sure)
  coors <- cbind(as.numeric(hits[,"tstart"]),as.numeric(hits[,"tend"]))
  ordhits <- hits[order(rowMeans(coors)),]
  ## swap ends for minus strand
  str <- ordhits[,"strand"]
  ordhits[str=="-",c("tend","tstart")] <- ordhits[str=="-",c("tstart","tend")]
  colhits <- NULL
  
  for ( i in 1:length(mord) ) {
    model <- mord[i]
    hits <- ordhits[ordhits[,"model"]==model,c("tstart","tend","strand",
                             "bit.score","E","index")]
    if ( nrow(hits)==0 ) next
    chits <- NULL
    indices <- NULL
    oldstrand <- "."
    oldstart <- 0
    oldend <- 0
    cnt <- 1
    for ( j in 1:nrow(hits) ) {
      strand <- as.character(hits[j,"strand"])
      start <- min(as.numeric(hits[j,c("tstart","tend")]))
      end <- max(as.numeric(hits[j,c("tstart","tend")]))
      bit <- as.numeric(hits[j,"bit.score"])
      e <- as.numeric(hits[j,"E"])
      idx <- hits[j,"index"]
      if ( oldend > start & oldstrand == strand) { 
        ## overlapping: inherit old ranges
        start<- min(start,oldstart)
        end  <- max(end,oldend)
        e    <- min(e,olde)
        bit  <- max(bit,oldbit)
        cnt  <- cnt+1
        indices <- ifelse(is.null(indices),oldidx,paste(indices,oldidx,sep=";"))
      } else if ( oldstart!=0 ) {
        ## non-overlapping: add previous hits
        if ( debug) cat(paste(i,j,"collapsing previous hit\n"))

        indices <- ifelse(is.null(indices),oldidx,paste(indices,oldidx,sep=";"))
        chits <- rbind(chits, c(model=model,strand=oldstrand,
                                start=oldstart,end=oldend,cnt=cnt,
                                bit=oldbit,e=olde,indices=indices))
        cnt <- 1
        indices <- NULL
      }
      oldstrand <- as.character(strand)
      oldstart <- start
      oldend <- end
      oldbit <- bit
      olde <- e
      oldidx <- idx
    }
    ## add last hit
    if ( debug) cat(paste(i,j,"collapsing last hit\n"))
    indices <- ifelse(is.null(indices),oldidx, paste(indices,oldidx,sep=";"))
    chits <- rbind(chits, c(model=model,strand=oldstrand,
                            start=oldstart,end=oldend,cnt=cnt,
                            bit=oldbit,e=olde,indices=indices))
    colhits <- rbind(colhits, chits)
  }
  if ( !is.null(colhits) ) {
    ## order hits by midpoint on target 
    mid <- rowMeans(matrix(as.numeric(colhits[,c("start","end")]),ncol=2))
    colhits <- colhits[order(mid),,drop=FALSE]
  }
  colhits
}

#' CHAINER: searches for ordered hits of different covariance models (CM)
#' 
#' takes infernal results for CM which have been derived from a larger
#' alignment, denoted subCM hits (cmhits), and reports
#' a chain of subCM hits which satisfy a 5'->3' ordering of the subCM
#' models (subcms)
#' TODO: open parallel chains, dont close chains at each non-fitting hit!
#' @param cmhits table of infernal hits for different subCM
#' @param subcms ordering of subCM
#' @param cmsub mapping of individual subCM to the guide model subCM definitions
#' @param overlaps a matrix giving the number of nucleotides by which subCMs
#' overlap
#' @param minl minimum length of a chain to be reported
#' @param maxr maximal index distance in subcm order (5'->3' order) in subcms
#' @param maxd maximum distance (in bp) between adjacent hits
#' @param ovlfilter require non-overlapping end hits
#' @param tovlf if TRUE, hits for subCM that overlap in the guide model also
#' must overlap on the target sequence
#' @param verb print progress messages
#' @param debug print debug messages
#'@export
chainer <- function(cmhits, subcms, cmsub, overlaps, minl=2, maxr=0, maxd=500, ovlfilter=FALSE, tovlf=FALSE, verb=TRUE, debug=FALSE) {

  if ( verb )
    cat(paste("CHAINING WITH: maxr=",maxr,"; maxd=",maxd,"; minl=",minl,"\n"))
  ## unify names in overlap matrix
  ## (converts "-" to "." as in column names of parsed dataframe)
  rownames(overlaps) <- make.names(rownames(overlaps))
  colnames(overlaps) <- make.names(colnames(overlaps))

  ## A) COLLAPSE HITS FROM SAME CUT RANGE
  colhits <- collapseHits(hits=cmhits, mmap=cmsub, mord=subcms,debug=debug)
  if ( is.null(colhits) ) return(NULL)

  ## order hits by midpoint on target, then by rank
  model <- as.character(colhits[,"model"])
  strnd <- as.character(colhits[,"strand"])
  ranks <- rep(0, length(model))
  for ( i in 1:length(model) ){
    ranks[i] <- which(subcms == model[i])
    if ( strnd[i] == "-" )
      ranks[i] <- which(rev(subcms) == model[i])
  }
  mid <- rowMeans(matrix(as.numeric(colhits[,c("start","end")]),ncol=2))
  colhits <- colhits[order(mid,ranks),,drop=FALSE]
  ## TODO:
  ## interestingly, there is one candidate more (NC_016027.1),
  ## if not pre-ordered by rank
  #colhits <- colhits[order(mid),,drop=FALSE]
  
  ## B) CONSTRUCT CHAINS FROM ORDERED LIST OF HITS
  breaks <- NULL # indicates causes of chain termination
  chains <- NULL # stores chains
  chain  <- NULL # current chain
  maxi <- length(subcms)
  oldidx <- 1
  oldmodel <- "dummy"
  oldstrand <- "."
  oldstart <- 0
  oldend <- 0

  for ( i in 1:nrow(colhits) ) {
    
    model <- make.names(colhits[i,"model"])
    strand <- as.character(colhits[i,"strand"])
    start <- as.numeric(colhits[i,"start"])
    end <- as.numeric(colhits[i,"end"])

    ## get rank in subCM order!
    rank <- which(make.names(subcms) == model)
    if ( strand=="-" ) rank <- which(rev(make.names(subcms)) == model )  
    
    if ( is.null(chain) ) {
      ## 1a) start chain (first chain only, see 1b for alternative start)
      chain <- i
    } else {

      ## 2) check criteria for chain extension

      ## distance ok? -> option: maxd
      distanceok <- strand==oldstrand & start-oldend < maxd

      ## ORDER:
      ## order and overlap are alternatives, if the order is wrong
      ## but hits overlap in the guideCM, 
      ## and (optionally also on the target, it is ok!
      ## this catches cases where on subCM of lower order rank matches 3'
      ## and the subCM of higher rank matches 5'
      
      ## subCM order ok? -> allow same hit in distance
      orderok <- oldrank <= rank
      
      ## overlapping in both, guide CM and on target?
      tovl <- length(intersect(start:end, oldstart:oldend))>0
      qovl <- overlaps[model,oldmodel]>0
      ## the target overlap is optional (option tovlf) to get hits in distance
      bothoverlap <- qovl & ( !tovlf | tovl )
      ## maximal index distance for overlapping? -> option: maxr
      rankok <- oldrank-rank < maxr  # implies oldrank < rank for maxr>0

      ## filter for max rank distance -> option: maxr
      overlapok <- bothoverlap & ifelse(maxr==0,TRUE, rankok)
      
      ## add if criteria are met
      addi <- distanceok & (orderok | overlapok)
      if (debug) cat(paste(i, addi, "\n"))
      if ( addi ) {
        ## 3) ADD TO CHAIN
        chain <- c(chain,i)
      } else {
        
        ## 4) check criteria for chain completion

        ## is minimum length reached ? -> minl
        lenok <- length(chain) >= minl

        ## do any two hits NOT overlap?
        mall <- unique(make.names(colhits[chain,"model"]))
        ovlok <- !ovlfilter | FALSE
        if ( length(chain)>1 ) 
          ovlok <- !ovlfilter | any(overlaps[mall,mall]==0)
        ## do last and first element overlap in guide? -> ovlfilter
        #mstart <- make.names(colhits[chain[1],"model"])
        #mend <- make.names(colhits[chain[length(chain)],"model"])
        #ovlok <- !ovlfilter | overlaps[mstart,mend]==0
        ## 5a) COMPLETE CHAIN
        if ( lenok & ovlok ) {
      
          chains <- append(chains,list(chain))
          breaks <- rbind(breaks, c(i=i,rank=rank,
                                    nstrand=strand, distance=(start-oldend),
                                    orderok=orderok, overlapok=bothoverlap,
                                    rankok=rankok, drank=(oldrank-rank)))
          if (debug)
            cat(paste("TAKING CHAIN", paste(chain,collapse=";"), "\n"))
        }else{
          if (debug)
            cat(paste("NOT TAKING CHAIN", paste(chain,collapse=";"),
                      lenok, ovlok, "\n"))
        }
        
        ## 1b) start new chain
        chain <- i
      }
    }
    oldrank <- rank
    oldmodel <- model
    oldstrand <- strand
    oldstart <- start
    oldend <- max(oldend,end)
  }
  ## 5b) complete last chain
  if ( length(chain) >= minl ) {
    mstart <- make.names(colhits[chain[1],"model"])
    mend <- make.names(colhits[chain[length(chain)],"model"])
    if ( !ovlfilter | overlaps[mstart,mend]==0 ) {
      chains <- append(chains,list(chain))
      breaks <- rbind(breaks, c(i=i,rank=rank, nstrand=".", distance=0,
                                orderok=NA, overlapok=NA,rankok=NA, drank=0))
    }
  }

  if ( is.null(chains) ) return(NULL)

  ## construct candidate hits from chain!
  candidates <- matrix(NA,ncol=8,nrow=length(chains))
  colnames(candidates) <- c("model","subCM range","subCM num",
                            "tstart","tend","strand", "max bit score","min E")
  cmrank <- 1:length(subcms) ## redo ranks because those above can't be named
  names(cmrank) <- subcms
  ## results:
  ## target coordinates, model, range and number of subCMs,
  ## max bit score and minimal e-value
  for ( i in 1:length(chains) ) {
    chainCMs <- unique(colhits[chains[[i]],"model"])
    chainRanks <- cmrank[chainCMs]
    chainRange <- paste(chainCMs[chainRanks==min(chainRanks)],"..",
                        chainCMs[chainRanks==max(chainRanks)],sep="")
    candidates[i,"model"] <- paste("subCM_",chainRange,sep="")
    candidates[i,"subCM range"] <- paste(range(chainRanks),collapse="-")
    candidates[i,"subCM num"] <- length(chainCMs)
                                                          
    candidates[i,c("tstart","tend")] <-
      range(as.numeric(colhits[chains[[i]],c("start","end")]))
    candidates[i,"strand"] <- unique(colhits[chains[[i]],"strand"])
    candidates[i,"max bit score"] <- max(as.numeric(colhits[chains[[i]],"bit"]))
    candidates[i,"min E"] <- min(as.numeric(colhits[chains[[i]],"e"]))
  }

  list(colhits=colhits, chains=chains, candidates=cbind(candidates,breaks))
}

## CHAINER VERSION 2 - NOT FINISHED/USED
## TODO: what is the difference to chainer v1?
## takes infernal subCM hits (cmhits), a subCM order (subcms) and reports
## a chain of hits
## TODO: open parallel chains, dont close chains at each non-fitting hit
chainer2 <- function(cmhits, subcms, cmsub, overlaps, minl=2, maxr=0,maxd=500, frac="notused",verb=TRUE) {

  if ( verb )
    cat(paste("CHAINING WITH: maxr=",maxr,"; maxd=",maxd,"; minl=",minl,"\n"))
  ## unify names in overlap matrix
  ## (converts "-" to "." as in column names of parsed dataframe)
  rownames(overlaps) <- make.names(rownames(overlaps))
  colnames(overlaps) <- make.names(colnames(overlaps))

  ## 1) collapse hits of same cut range
  ## order by start on target (probably already ordered, but make sure)
  #ordhits <- cmhits[order(cmhits[,"tstart"],cmhits[,"tend"]),]
  ordhits <- cmhits[order(rowMeans(cmhits[,c("tstart","tend")])),]
  ordhits[,"model"] <- cmsub[as.character(ordhits[,"model"])]
  str <- ordhits[,"strand"]
  ## swap ends for minus strand
  ordhits[str=="-",c("tend","tstart")] <- ordhits[str=="-",c("tstart","tend")]
  colhits <- NULL
  ## subcms are ordered!
  cmrank <- 1:length(subcms)
  for ( i in 1:length(subcms) ) {
    subcm <- subcms[i]
    hits <- ordhits[ordhits[,"model"]==subcm,c("tstart","tend","strand",
                             "bit score","E")]
    chits <- NULL
    oldstrand <- "."
    oldstart <- 0
    oldend <- 0
    cnt <- 1
    for ( j in 1:nrow(hits) ) {
      strand <- as.character(hits[j,"strand"])
      start <- min(hits[j,c("tstart","tend")])
      end <- max(hits[j,c("tstart","tend")])
      bit <- hits[j,"bit score"]
      e <- hits[j,"E"]
      ## overlapping: inherit old ranges
      if ( oldend > start & oldstrand == strand) { 
        start <- min(start,oldstart)
        end <- max(end,oldend)
        e <- min(e,olde)
        bit <- max(bit,oldbit)
        cnt <- cnt+1
      } else if ( oldstart!=0 ) { ## non-overlapping
        rank <- cmrank[i]
        if ( oldstrand=="-" )
          rank <- rev(cmrank)[i]
        ##cat(paste(i,j,"collapsing previous hit\n"))
        chits <- rbind(chits,
                       c(i=rank,model=subcm,strand=oldstrand,
                         start=oldstart,end=oldend,cnt=cnt,
                         bit=oldbit,e=olde))
        cnt <- 1
      }
      oldstrand <- as.character(strand)
      oldstart <- start
      oldend <- end
      oldbit <- bit
      olde <- e
    }
    rank <- cmrank[i]
    if ( oldstrand=="-" )
      rank <- rev(cmrank)[i]
                                        #cat(paste(i,j,"collapsing last hit\n"))
    chits <- rbind(chits,c(i=rank,model=subcm,strand=oldstrand,
                           start=oldstart,end=oldend,cnt=cnt,
                           bit=oldbit,e=olde))
    colhits <- rbind(colhits, chits)
  }
  mid <- rowMeans(matrix(as.numeric(colhits[,c("start","end")]),ncol=2))
  ## order hits by midpoint on target, then by index
  colhits <- colhits[order(mid,as.numeric(colhits[,"i"])),]


  if ( nrow(colhits)== 0 ) return(NULL)
  
  ## CHAINER
  breaks <- NULL
  ochains <- NULL
  chains <- NULL
  for ( i in 1:nrow(colhits) ) {
    idx <- as.numeric(colhits[i,"i"])
    model <- make.names(colhits[i,"model"])
    strand <- colhits[i,"strand"]
    start <- as.numeric(colhits[i,"start"])
    end <- as.numeric(colhits[i,"end"])

    added <- FALSE
    keep <- rep(TRUE, length(ochains))
    rm <- rep(TRUE, length(ochains))
    ## go through open chains
    if ( length(ochains)>0 ) {
      for ( j in length(ochains):1 ) {
        
        chain <- ochains[[j]]
        i_1 <- chain[length(chain)]
        oldidx <- as.numeric(colhits[i_1,"i"])
        oldmodel <- make.names(colhits[i,"model"])
        oldstrand <- colhits[i_1,"strand"]
        oldstart <- as.numeric(colhits[i_1,"start"])
        oldend <- as.numeric(colhits[i_1,"end"])
        
        ## 1) RM or CLOSE CHAIN?
        if ( start-oldend >= maxd  ) {
          if ( length(chain)>minl ) rm[j] <- FALSE
          keep[j] <- FALSE
          next
        }

        ## if it has been added, skip
        ## brings no improvement!
       # if ( added ) next
        
        ## 2) ADD TO CHAIN
        ## CRITERIA
        ## check strand
        strandok <- strand==oldstrand 
        
        ## check index order 
        orderok <- oldidx < idx
        
        ## both overlapping?
        tovl <- length(intersect(start:end, oldstart:oldend))>0
        qovl <- overlaps[model,oldmodel]>0
        bothoverlap <- tovl & qovl
        
        ## minimal index distance for overlapping
        rankok <- oldidx-idx < maxr  # implies oldidx < idx for maxr>0
        ## fiter for max rank distance
        overlapok <- bothoverlap & ifelse(maxr==0,TRUE, rankok)
        ## add if all criteria are met
        addi <- strandok & (orderok | overlapok)

        ## TODO: additional check - add only to closest chain!?
        if ( addi ) {
          ## 2) add to chain
          ochains[[j]] <- c(ochains[[j]],i)
          added <- TRUE
        }
      }
    }
    ## 3) rm and close chains
    ## add if length threshold was ok
    chains <- append(chains, ochains[!keep & !rm])
    ochains <- ochains[keep]
    ## 4) start new chain
    if ( !added )
      ochains <- append(ochains, list(i))
  }
  ## add remaining
  if ( length(ochains)>0 )
    for ( j in 1:length(ochains) )
      if ( length(ochains[[j]])>minl ) append(chains, ochains[j])
  
  ## TODO: untangle
  ## 1) rm overlapping
  ## 2) crop ends, if end of another chain
   
  ## candidates!
  ## add required fields to be treated as hit file
  candidates <- matrix(NA,ncol=3,nrow=length(chains))
  for ( i in 1:length(chains) ) 
    candidates[i,2:3] <-range(as.numeric(colhits[chains[[i]],c("start","end")]))
  colnames(candidates) <- c("model","tstart","tend")
  candidates[,"model"] <- "subCM chain"
  
  list(colhits=colhits, chains=chains, candidates=cbind(candidates))
}




## SEQUENCE AND GENOME FEATURE FILE PARSING


## SEQUENCE UTILS (I/O, conversions)


## convert an alignment table to a string in stockholm format
#'@export
tab2stk <- function(tab, au="R::tab2stk", gc=NA) {
  ## header
  header <- paste("# STOCKHOLM 1.0\n#=GF AU",au,"\n\n")  
  ## get offset <seqname> <alignment>
  seqname <- rownames(tab)
  ## order: GC lines last
  seqname <- c(seqname[!seqname%in%gc], seqname[seqname%in%gc])
  tab <- tab[seqname,]
  seqname[seqname%in%gc] <- paste("#=GC",seqname[seqname%in%gc])
  seqname <- strsplit(seqname,"")
  offset <- max(unlist(lapply(seqname,length)))+2
  ## append spaces
  seqname <- unlist(lapply(seqname, function(x) {paste(paste(x,collapse=""),paste(rep(" ",offset-length(x)),collapse=""),sep="")}))
  alis <- apply(tab,1, function(x) paste(x,collapse=""))
  stk <- paste(header, paste(seqname,alis,"\n",collapse=""),"//",sep="")
  stk
}

## function to retrieve a useful ID from a fastaheader
getSeqId <- function(header, id="ref"){
  new <- NULL
  for ( x in header ) {
    x <- sub(">","",x)
    ## ncbi headers, e.g.
    ## >gi|38349555|ref|NC_005213.1| Nanoarchaeum equitans Kin4-M chromosome, complete genome
    x <- unlist(strsplit(x,"\\|"))
    if ( length(x)>1 ) {
      idx <- which(x==id)
      if ( length(idx)>0 )
        x <- x[idx+1]
    }
    new <- c(new,x)
  }
  new    
}

## extract NCBI acc and gi IDs from fasta headers
#'@export
fastaGetIds <- function(header) {
  
  if ( length(header)>1 ) {
    all <- NULL
    for ( head in header ) {
      all <- append(all, list(fastaGetIds(head)))
    }
    return(all);
  }
  ## rm >
  header <- sub("^>","",header)
  ## split by |
  header <- unlist(strsplit(header,"\\|"))
  gi <- acc <- desc <- ""
  if ( length(header)>1 ) {
    idx <- which(header=="gi")
    if ( length(idx)>0 )
      gi <- header[idx+1]
    idx <- which(header=="ref") ## TODO generalize, also e.g "gb"
    if ( length(idx)>0 ) {
      acc <- header[idx+1]
      ## rm version
      acc <- sub("\\.[1-9]+$","",acc)
    }
  }
  desc <- header[length(header)]
  list(gi=gi,acc=acc,desc=desc)
}

#' read a FASTA file
#' 
#' modified from library("Biostrings")
#' @param file a FASTA file
#'
#' @param checkComments 
#' @param strip.descs 
#' @param split.desc 
#'
#'@export
readFASTA <- function (file, checkComments = TRUE, strip.descs = TRUE, split.desc="") 
{
    if (is.character(file)) {
        file <- file(file, "r")
        on.exit(close(file))
    }
    else {
        if (!inherits(file, "connection")) 
            stop("'file' must be a character string or connection")
        if (!isOpen(file)) {
            open(file, "r")
            on.exit(close(file))
        }
    }
    s1 <- scan(file = file, what = "", sep = "\n", quote = "", 
        allowEscapes = FALSE, quiet = TRUE)
    if (checkComments) {
        comments <- grep("^;", s1)
        if (length(comments) > 0) 
            s1 <- s1[-comments]
    }
    descriptions <- which(substr(s1, 1L, 1L) == ">")
    numF <- length(descriptions)
    if (numF == 0) 
        stop("no FASTA sequences found")
    dp <- descriptions + 1L
    dm <- descriptions - 1L
    end <- c(dm[-1], length(s1))
    lapply(seq_len(numF), function(i) {
        desc <- s1[descriptions[i]]
        if (strip.descs) 
            desc <- substr(desc, 2L, nchar(desc))
        details <- NULL
        if ( split.desc != "" ) {
          desc <- unlist(strsplit(desc,split.desc))
          if ( length(desc)>2 ) stop("seq id not compatible with split.desc")
          details <- desc[2]
          desc <- desc[1]
        }
        if (end[i] >= dp[i]) {
            seq <- paste(s1[dp[i]:end[i]], collapse = "")
        }
        else {
            warning("record \"", desc, "\" contains no sequence")
            seq <- ""
        }
        list(desc = desc, details=details, seq = seq)
    })
}

#'@export
parseAlignment <- function(alf) {
  if ( missing(alf) ) {  
    cat(paste("no aligment file provided.\n"))
    return(NULL)
  }
  ## convert stk to tab, depending on file ending
  if ( length(grep("\\.stk$", alf))>0 | length(grep("\\.sto$", alf))) {
    tatadir <- system("env|grep TATADIR", intern=TRUE)
    if ( length(tatadir)==0 ) {
      cat(paste("ERROR: can't find environment variable TATADIR\n"))
    }else{
      tatadir <- sub("TATADIR=","",tatadir)
    }
    tmpfile <- paste(sample(c(0:9,letters[1:5])),collapse="")
    cmd <- paste(file.path(tatadir,"introns/scripts/stk2tab.pl"), alf,
                 ">",tmpfile)
    dat <- system(cmd, intern=T)
    alf <- tmpfile
  }
  ## parse alignment
  ali <- read.csv(alf,header=F,sep="\t",colClasses="character")
  ## rm temporary file
  if ( exists("tmpfile",mode="character") ) unlink(tmpfile)
  ## generate alignment matrix
  alimat <- t(matrix(unlist(strsplit(ali[,2],"")), ncol=nrow(ali)))
  rownames(alimat) <- ali[,1]
  alimat
}

#'@export
annotateAlignment <- function(anf, alf, au, empty) {

  if ( missing(au) ) au <- "R::annotateAlignment.R"
  if ( missing(empty) ) empty <- "~"
  if ( missing(anf) ) {  
    cat(paste("no annotation file provided.\n"))
    return(NULL)
  }
  if ( missing(alf) ) {  
    cat(paste("no alignment file given, use anf=<file>\n"))
    return(NULL)
  }
  
  ## generate alignment matrix
  alimat <- parseAlignment(alf)
  
  ## parse alignment annotation file
  cs <- readFASTA(anf,strip.descs=TRUE)
  for ( fs in cs ) 
    assign(sub(":.*","",fs$desc),unlist(strsplit(fs$seq,"")))
  lines <- sub(":.*","",unlist(lapply(cs, function(x) x$desc)))
  names(cs) <- lines

  if ( sum(duplicated(lines))>0 )
    cat(paste("WARNING: multiple lines with the same id in annotation file\n"))
  
  ## get mapping!
  csstr_ali <- alimat["GC_SS_cons",]
  ## simple mapping, if SS_cons single bases are equivalent
  cs2ali <- which(!csstr_ali %in% c("~","."))

  ## map not matching??
  #ssmin <- SS_cons
  ### add pk
    ## 201805: removed, seems to stem from global definitions during devel
  #if ( exists("SS_pkno",mode="character") ) {
  #  pknos <- SS_pkno %in% c(letters,toupper(letters))
  #  ssmin[pknos] <- SS_pkno[pknos]
  #}
  #ssmin2SS_cons <- which(ssmin %in% c("<",">","(",")","[","]", letters, toupper(letters)))
  
  ## check and rm consensus structure in alignment
  ##if ( exists("SS_cons",mode="character") ) {
  ##  if ( sum(csstr_ali[cs2ali] != SS_cons)>0 )
  ##    cat(paste("WARNING consensus structures differ!\n"))
  ##}
  ## check and rm consensus sequence
    ## 201805: removed, seems to stem from global definitions during devel
  #if ( exists("RF",mode="character") & "GC_RF" %in% rownames(alimat)  ) {
  #  csseq_ali <- alimat["GC_RF",]
  #  if ( sum(csseq_ali[cs2ali] != RF)>0 )
  #    cat(paste("WARNING consensus sequences differ\n"))
  #}

  ## old annotations, prefix GC stems from parsing of stk file
  oldlines <- grep("^GC_",rownames(alimat),value=T)
  
  ## construct annotation
  lines <- lines[!lines%in%rownames(alimat)]
  ann <- matrix(empty, ncol=ncol(alimat), nrow=length(lines))
  rownames(ann) <- lines
  for ( line in lines ) {
    if ( line %in% rownames(alimat) ) next
    ann[line,cs2ali] <- get(line)  
  }  
  list(ali=rbind(alimat,ann),au=au,gc=c(lines,oldlines))
}


### GENOME SEARCH UTILS
## guide CM - subCM index file
#' parse the subCM guide model index file
#' @param gdf the subCM guide model index file
#' @export
parseGuideCM <- function(gdf) {
  cmidx <- read.table(gdf)
  ## RE-ORDER - NOTE THAT THIS ORDER IS USED BY THE CHAINER
  cmidx <- cmidx[order(rowMeans(cmidx[,c("lcoor","rcoor")])),]
  ## subCM nms
  allsubcms <- paste(cmidx[,1],"-",cmidx[,2],sep="")
  ## subCM colors
  cols <- as.character(cmidx[,"col"])
  names(cols) <- allsubcms
  ## overlaps
  overlaps <- cmidx[,grep("^ovl_",colnames(cmidx))]
  ## unify names!!
  colnames(overlaps) <- sub("^ovl_","",colnames(overlaps))
  
  ## WARNING: colnames(overlaps) also has "-" converted to "."
  
  ## order DAG: hits must have at least two non-connected nodes, i.e.,
  ## non-overlapping hits in the correct order
  nodes <- colnames(overlaps)
  dag <- NULL
  for ( i in 1:(nrow(overlaps)-1) ) {
    src <- nodes[i]
    targets <- which(overlaps[i,]>0)
    targets <- nodes[targets[targets>i]]
    for ( trg in targets ) 
      dag <- rbind(dag, c(src,trg))
  }
  guide <- list(overlaps=overlaps, dag=dag, colors=cols, subcms=allsubcms)
}

## parse IDs, names, products, from descriptions in gff files into a matrix
#' parse gff file description fields
#'
#' searches for pairs of <ID>=<value> in the description field of
#' an entry in a gff genome annotation file. A list of IDs can be passed,
#' and the function returns a matrix with a column for each ID and
#' the values found for each description.
#' @param desc vector of strings, the description field of a gff file
#' @param fields a vector of strings providing the ID to search
#' @export
grepDescription <- function(desc, fields=c("product","Name","ID")) {

  res <- matrix("", nrow=length(desc), ncol=length(fields))
  colnames(res) <- fields
  for ( field in fields ) {
    range <- regexpr(paste(field,"=.*",sep=""),desc)
    tmp <- regmatches(desc,range)
    tmp <- sub(paste(".*",field,"=",sep=""),"",tmp)
    tmp <- sub(";.*","",tmp)
    res[range!=-1,field] <- tmp
  }
  res
}


#' parses the output of various genome scanning tools
#'
#' parses the output tables of various genome scanning tools, ie.,
#' RFAM scans with infernal, PFAM scans with hmmer, or 
#' NCBI blast. The tools must be set to output a table of results,
#' and the columns can be specified, or a set of pre-defined columns
#' for standard table outputs of the tools by using the argument \code{type}.
#' Pre-defined types are "cmchain" (subCM chainer),
#' "blast", "pfam", "rfam1" (old version of infernal), "rfam11" (version 1.1+
#' of infernal), "gff" (gff genome annotations), and "phispy"
## TODO: type=phispy: "ID ACC start end"
#' @param files a list of table files, the output of various genome
#' scanning tools
#' @param type the type of the files, to use pre-defined column names,
#' see Details
#' @param colnames the list of column names to be found in the input
#' \code{files}; not required if the file format matches any of the pre-defined
#' inputs in argument \code{type}.
#' @param inc a result filter string, only rows which contain this string will
#' be used, eg. \code{inc="!"} to use only files with a "!" in infernal searches
#' @param header logical indicating whether a header line is present in
#' the input files
#' @param sep the field separator in the input files, this will be set
#' automatically for some predefined types, eg. "<tab>" for types "cmchain",
#' "gff" and "phispy"
#' @param comment.char character used for comment lines
#' @export
parseHomHits <- function(files, type, colnames, inc="", header=FALSE, sep="", comment.char="#"){

  ## filter regex!
  if( inc!="" )
    inc <- paste("|grep -P \"",inc,"\"","",sep="")
  
  if ( missing(colnames) ) {
    if ( !missing(type) ) {
      if ( type=="blast" ) 
        colnames <- c("model","target","% identity","alignment length","mismatches","gap opens","mstart","mend","tstart","tend","E","bit.score")
      if ( type=="pfam" ) 
        colnames <- c("target","tacc","tlen","model",  "macc", "mlen","E","score","bias", "X", "of", "cE",  "iE", "score2", "bias2", "mstart", "mend", "tstart","tend","tstart2","tend2", "acc", "desc")
      if ( type=="rfam1" )
        colnames <- c("model","target","tstart","tend","mstart","mend","bit.score","E","GC")
      if ( type=="rfam11" )
        colnames <- c("target","tacc","model","macc","mdl","mstart","mend","tstart","tend","strand","trunc","pass","GC","bias","bit.score","E","inc","desc")
      if ( type=="cmchain" ) {
        header <- TRUE
        sep <- "\t"
        colnames <- c("cmchain.ID","target","guideCM","model","subCM.range","subCM.num","tstart","tend","strand","max.bit.score","min.E","tdesc")
      }
      if ( type=="gff" ) {
        sep <- "\t"
        colnames <- c("chr","source","type","start","end","xx","strand","xxx","desc")
      }
      if ( type=="phispy" ) {
	sep <- "\t"
	colnames <- c("phage.ID", "target", "tstart", "tend")
      }
    }
    colClasses <- c(rep("character",5),rep("integer",4),rep("character",2),
                    rep("numeric",5), rep("character",2))
  }
    
  if ( length(files)>1 ) {
    tmpfile <- paste(sample(c(0:9,letters[1:5])),collapse="")
    cmd <- paste("cat",paste(files,collapse=" "),inc,">",tmpfile)
    system(cmd)
    file <- tmpfile
  } else { 
    file <- files
  }
  if ( header )
    hits <- read.csv(file, sep=sep,header=header,quote="",comment.char=comment.char)
  else
    hits <- read.csv(file, sep=sep, fill=TRUE,col.names=c(colnames,1:20),
                     header=header,quote="",comment.char=comment.char)
  ## collapse last description column
  hits[,length(colnames)] <- apply(hits[length(colnames):ncol(hits)],1,
                                   function(x) paste(x[!is.na(x)],collapse=" "))
  hits[,length(colnames)] <- gsub(" +$","",hits[,length(colnames)])
  hits <- hits[,1:length(colnames)]
  ## parse line-by-line manually, since the space-delim files
  ## plus free text in last column causes problems
  #lines <- scan(file=file, what="", sep="\n", quote="",
  #              allowEscapes=FALSE, quiet=TRUE, comment.char="#")
  #hits <- NULL
  #for ( line in lines ) { ## this takes very long: look for alternative!
  #  fields <- unlist(strsplit(line," "))
  #  fields <- fields[fields!=""]
  #  fields[length(colnames)] <-
  #    paste(fields[length(colnames):length(fields)],collapse=" ")
  #  hits <- rbind(hits, fields[1:length(colnames)])
  #}
  #colnames(hits)[1:length(colnames)] <- colnames
  
  ## DANGER: tmpfile is deleted below!! watch carefully
  if ( length(files)>1 )  unlink(tmpfile)
  hits
}

## plot Rfam/Pfam/Blast hits, where hits must have
## infernal-like column headers (as returend by parseHomHits)
#' plot hits from RFAM, PFAM, blast or cmchainer genome scans
#'@export
plotHomHits <- function(hits=list(blast=blhits, "full CM"=cmfhits, candidates=candidates), subhits=subhits, subids=subcms,xlim=c(1,seqlen),cols=NULL, ai1=FALSE) {
  
  if ( missing(subids) )
    subids <- unique(subhits[,"model"])

  ## sum full model hits
  if ( ai1 ) {
    fhitxy <- rep(list(NA), length(hits))
    names(fhitxy) <- names(hits)
    for ( id in names(hits) ) {
      hit <- hits[[id]]
      if ( nrow(hit)==0 ) next
      hitx <- NULL
      hity <- NULL
      for ( i in 1:nrow(hit) ) {
        range <- as.numeric(hit[i,c("tstart","tend")])
        hitx <- c(hitx,range[1]:range[2])
      }
      hity <- rep(0,length(hitx))
      for ( i in 1:nrow(hit) ) {
         range <- as.numeric(hit[i,c("tstart","tend")])
         range <- range[1]:range[2]
         hity[hitx%in%range] <- hity[hitx%in%range] +1
      }
      x <- hitx[hitx>=xlim[1] & hitx<=xlim[2]]
      y <- hity[hitx>=xlim[1] & hitx<=xlim[2]]
      fhitxy[[id]] <- list(xy=xy.coords(x=x,y=y,ylab=id,xlab=NA))
    }
  }

  ## subhits: sum up hits for the same submodels
  hitxy <- rep(list(NA), length(subids))
  names(hitxy) <- subids
  for ( id in subids ) {
    hitx <- NULL
    hity <- NULL
    hit <- subhits[subhits[,"model"]==id,]
    if ( nrow(hit) != 0 ) {
      for ( i in 1:nrow(hit) ) {
        range <- as.numeric(hit[i,c("tstart","tend")])
        hitx <- c(hitx,range[1]:range[2])
      }
      hity <- rep(0,length(hitx))
      for ( i in 1:nrow(hit) ) {
         range <- as.numeric(hit[i,c("tstart","tend")])
         range <- range[1]:range[2]
         hity[hitx%in%range] <- hity[hitx%in%range] +1
      }
    }else{
      #cat(paste(id, "NO HITS\n"))
      hitx <- 0
      hity <- 0
    }
    x <- hitx[hitx>=xlim[1] & hitx<=xlim[2]]
    y <- hity[hitx>=xlim[1] & hitx<=xlim[2]]
    hitxy[[id]] <- list(xy=xy.coords(x=x,y=y,ylab=id,xlab=NA))
    #cat(paste(id, paste(hity,collapse=";"),"\n"))
  }
  

  ## number of rows
  nrows <- length(hits) + ifelse(ai1, 1, length(hitxy)) #nrow(shits)

  par(mfcol=c(nrows,1),mai=c(0.1,.5,0.1,0),mgp=c(2,1,0))
  for ( i in 1:length(hits) ) {
    id <- names(hits)[i]
    if ( ai1 ) {
      xy <- fhitxy[[i]]$xy
      if ( length(xy$x)==0 ) {
        plot(0, col=NA,xlim=xlim,ylim=c(0,1),axes=F,ylab=xy$ylab,xlab=NA)
      } else { 
        plot(xy,type="h",xlim=xlim,ylim=c(0,max(xy$y)),axes=F,ylab=id,xlab=NA)
      }
      axis(1,at=c(1,pretty(xlim),max(xlim)))
      axis(2) 
     }else{
      plot(0, col=NA,xlim=xlim,ylim=c(0,1),axes=F,ylab=id,xlab=NA)
      axis(1,at=c(1,pretty(xlim),max(xlim)))
      if ( nrow(hits[[i]])>0 ) {
        for ( j in 1:nrow(hits[[i]]) ) {
          x <- as.numeric(hits[[i]][j,c("tstart","tend")])
          polygon(c(x,rev(x)), c(0,0,.75,.75),col=j,border=j)
        }
        legend("right",legend=hits[[i]][,"model"],col=1:nrow(hits[[i]]),pch=15)
      }
    }
  }
  if ( ai1 ) {
    ylim <- c(0,max(unlist(lapply(hitxy, function(x)
                                  ifelse(length(x$xy$x)>0,max(x$xy$y),0)))))
    plot(0, col=NA,xlim=xlim,ylim=ylim,axes=F,ylab="sub-CMs",xlab=NA)
    axis(1,at=c(1,pretty(xlim),max(xlim)))
    axis(2) 
  }
  for ( i in 1:length(hitxy) ) {
    id <- names(hitxy)[i]
    xy <- hitxy[[i]]$xy
    ##cat(paste("plotting", id, "\n"))
    if ( ai1 ) {
      lines(xy,col=ifelse(id%in%names(cols),cols[id],1),type="h")
    }else{
      if ( length(xy$x)==0 ) {
        plot(0, col=NA,xlim=xlim,ylim=c(0,1),axes=F,ylab=xy$ylab,xlab=NA)
      } else {
        plot(xy,type="h",xlim=xlim,ylim=c(0,max(xy$y)),
             ylab=xy$ylab,
             axes=F,col=ifelse(id%in%names(cols),cols[id],1))
      }
      axis(1,at=c(1,pretty(xlim),max(xlim)))
      axis(2)
    }
  }
  #for ( i in 1:nrow(shits) ) {
  #  id <- rownames(shits)[i]
  #  hitx <- which(shits[i,]>0)
  #  hity <- shits[i,hitx] 
  #  plot(hitx,hity,type="h",xlim=xlim,ylim=c(0,max(hity)+.1*max(hity)),
  #       axes=F,ylab=id,col=ifelse(id%in%names(cols),cols[id],1))
  #  axis(1,at=c(1,pretty(xlim),max(xlim)))
  #  axis(2)
  #}  
}


#' number of all hits at each genomic position
#' 
#' number of all hits of the same type per nucleotide position
#' and constructs a genome data matrix
#' @param hits table of hits from genome scans
#' @param type name of the column where the hit type is specified
#' @param coors names of the columns where start and end coordinate
#' on the target sequence are specified
#' @export
hits2data <- function(hits, ids, type="model", coors=c("tstart","tend")) {
  if ( missing(ids) )
    ids <- unique(hits[,type])
  else hits <- hits[hits[,type]%in%ids, ]

  ## x coordinates
  x <- NULL
  for ( i in 1:nrow(hits) ) {
    range <- as.numeric(hits[i,c("tstart","tend")])
    range <-range[1]:range[2]
    x <- c(x, range[!range%in%x])
  }
  x <- sort(unique(x))

  ## y data: sum up hits along coordinates
  data <- matrix(0, nrow=length(x), ncol=2+length(ids))
  colnames(data) <- c("chr","coor",ids)
  data[,"chr"] <- 1
  data[,"coor"] <- x
  for ( i in 1:nrow(hits) ) {
    id <- hits[i,type]
    range <- as.numeric(hits[i,c("tstart","tend")])
    range <-range[1]:range[2]
    data[x%in%range,id] <- data[x%in%range,id] + 1
  }
  data[data==0] <- NA
  data
}

#' sums up genome hits of the same type and generates a feature list
#' 
#' convert a hit table from of a genomce to a genome feature list
#' with columns name,type,chr,start,end,strand,color and
#' IDs as rownames
#' @param hits table of hits from genome scans
#' @param ids IDs for the hits, if missing hits will be enumerated as IDs
#' @param type name of the column where the hit type is specified
#' @param colors a vector of colors for all available types
#' @param coors names of the columns where start and end coordinate
#' on the target sequence are specified
#' @export
hits2features <- function(hits,ids,type="model",colors,
                          coors=c("tstart","tend")) {

  if ( missing(ids) ) ids <- paste("feature",1:nrow(hits),sep="")


  features <- matrix("", nrow=nrow(hits), ncol=7)
  colnames(features) <- c("name","type","chr","start","end","strand","color")
  
  for ( i in 1:nrow(hits) ) {
    features[i,"type"] <- as.character(hits[i,type])
    features[i,c("start","end")] <- as.numeric(hits[i,coors])
    features[i,"strand"] <- as.character(hits[i,"strand"])
  }
  features[,"chr"] <- 1
  rownames(features) <- features[,"name"] <- ids

  if (missing(colors) ) {
    types <- unique(features[,"type"])
    colors <- rgb.tables(length(types),
                         red=  c(0.8,0.2,1),
                         green=c(0.5,0.4,0.8),
                         blue= c(0.2,0.2,1))
    names(colors) <- types
  }
  features[,"color"] <- colors[features[,"type"]]

  features
}
## sums up hits of the same type to xy coordinates
hits2xy <- function(hits, ids, type="model",coors=c("tstart","tend")) {

  if ( missing(ids) )
    ids <- as.character(unique(hits[,type]))
  else hits <- hits[hits[,type]%in%ids, ]

  ## subs: sum up s for the same submodels
  xy <- rep(list(NA), length(ids))
  names(xy) <- ids
  for ( id in ids ) {
    x <- NULL
    y <- NULL
    hit <- hits[hits[,"model"]==id,]
    if ( nrow(hit) != 0 ) {
      for ( i in 1:nrow(hit) ) {
        range <- as.numeric(hit[i,c("tstart","tend")])
        x <- c(x,range[1]:range[2])
      }
      y <- rep(0,length(x))
      for ( i in 1:nrow(hit) ) {
         range <- as.numeric(hit[i,c("tstart","tend")])
         range <- range[1]:range[2]
         y[x%in%range] <- y[x%in%range] +1
      }
    }else{
      #cat(paste(id, "NO S\n"))
      x <- 0
      y <- 0
    }
    xy[[id]] <- list(xy=xy.coords(x=x,y=y,ylab=id,xlab=NA))
  }
  xy
}

## sums up hits of the same type to block coordinats for drawing polygons
hits2blocks <- function(hits, ids, type="model",coors=c("tstart","tend")) {

  if ( missing(ids) )
    ids <- as.character(unique(hits[,type]))
  else hits <- hits[hits[,type]%in%ids, ]

  for ( i in 1:nrow(hits) ) {
    y.p <- c(0,1,1,0)
    x.p <- rep(as.numeric(hits[i,c("tstart","tend")]),each=2)
  }
  
  ## subs: sum up s for the same submodels
  xy <- rep(list(NA), length(ids))
  names(xy) <- ids
  for ( id in ids ) {
    x <- NULL
    y <- NULL
    hit <- hits[hits[,"model"]==id,]
    if ( nrow(hit) != 0 ) {
      for ( i in 1:nrow(hit) ) {
        range <- as.numeric(hit[i,c("tstart","tend")])
        x <- c(x,range[1]:range[2])
      }
      y <- rep(0,length(x))
      for ( i in 1:nrow(hit) ) {
         range <- as.numeric(hit[i,c("tstart","tend")])
         range <- range[1]:range[2]
         y[x%in%range] <- y[x%in%range] +1
      }
    }else{
      #cat(paste(id, "NO S\n"))
      x <- 0
      y <- 0
    }
    xy[[id]] <- list(xy=xy.coords(x=x,y=y,ylab=id,xlab=NA))
  }
  xy
}

## plot 3D genomeData as a heatmap
## NOTE: fast indexing via chrS (cumulative chrosome lengths)
## is possible only for fully expanded 'data')
plotHeat <- function(data, coors, breaks, colors, ylab="", axes=FALSE, colnorm=FALSE, chrS, coor) {
  
  chr <- coors[1]
  xlim <- sort(coors[2:3])

  ## split off coordinate columns, if not separately supplied
  ## TODO: use as alternative to chrS
  ## TODO: clean this up a bit (chrS vs. coor vs. data)
  firstcol <- 1
  if ( missing(coor) ) {
    coor <- data[,c("chr","coor")]
    firstcol <- 3
  } 
  ## cut to xlim - TODO: consolidate with coor in plotFeatures and plotBlocks
  if ( missing(chrS) ) { ## search indices - SLOW
    idx <- which(as.numeric(coor[,"chr"]) == chr &
                 (as.numeric(coor[,"coor"]) >= xlim[1] &
                  as.numeric(coor[,"coor"]) <= xlim[2]))
  } else { ## take direct index - ONLY FOR EXPANDED and ORDERED DATA
    start <- xlim[1]+chrS[chr]
    end <- xlim[2]+chrS[chr]
    if ( start < 1 ) start <- 1
    if ( end > nrow(data) ) end <- nrow(data) ## TODO: cut by chromosome!
    idx <- start:end
  }
  
  dat <- as.matrix(data[idx,firstcol:ncol(data),drop=FALSE])
  x <- coor[idx,"coor"]
  y <- 1:ncol(dat)

  if ( length(x)==0 ) {  ## empty?
    plot(1,xlim=xlim,col=NA,axes=FALSE,xlab="chromosome position",ylab=ylab)
  }else{

    if ( colnorm ) {
      dat <- t(apply(dat,1,function(x) {
        if (max(x)==0&min(x)==0) x else (x-min(x))/(max(x)-min(x))}))
    }
    
    if ( missing(breaks) ) {
      if ( !missing(colors) ) nbreaks <- length(colors)+1
      else nbreaks <- 101
      breaks <- seq(min(dat,na.rm=TRUE),max(dat,na.rm=TRUE),length.out=nbreaks)
    }
    nbreaks <- length(breaks)
    if ( missing(colors) )
      colors <- gray(seq(1,0,length.out=nbreaks-1))
    
    
    p1 <- image(x=x,y=y,z=dat, axes=FALSE, ylab=ylab, xlim=xlim,
                xlab="chromosome position",breaks=breaks,col=colors)
    }  
  if ( axes ) {
    axis(1)
    axis(2,las=2)
  }
}

## plots lines from a matrix of data


#' plots a matrix of genome coordinate data (columns 1 and 2 are
#' chr and pos)
#' NOTE: fast indexing via chrS (cumulative chrosome lengths)
#' is possible only for fully expanded 'data')
#' TODO: replace this by genomeBrowser
#' @export
plotBlocks <- function(data,coors,colors, shaded=TRUE, baseline=-1, log="", ylim, ylim1, ylab=NA, verb=FALSE, lines=FALSE, blockwise=TRUE, smooth=FALSE, filter, axis1=TRUE, extend=0, chrS, args, ...) {

  ## parse arguments, which will also override other 
  if ( !missing(args) ) {    
    for ( i in 1:length(args) )       
      assign(names(args)[i],args[[i]])
  }    

  if ( missing(colors) ) {
    colors <- rep("#000000",ncol(data)-2)
    names(colors) <- colnames(data)[3:ncol(data)]
  }
  chr <- coors[1]
  xlim <- sort(coors[2:3])
  ## cut to xlim - TODO: consolidate this with coor in plotFeatures and plotHeat
  if ( missing(chrS) ) { ## search indices - SLOW
    idx <- which(as.numeric(data[,"chr"]) == chr &
                 (as.numeric(data[,"coor"]) >= xlim[1] &
                  as.numeric(data[,"coor"]) <= xlim[2]))
  } else { ## take direct index
    start <- xlim[1]+chrS[chr]
    end <- xlim[2]+chrS[chr]
    if ( start < 1 ) start <- 1
    if ( end > nrow(data) ) end <- nrow(data) ## TODO: cut by chromosome!
    idx <- start:end
  }
  if ( extend>0 )
    idx <- c((min(idx)-extend):(max(idx)+extend))


  dat <- data[idx,,drop=FALSE]
  ## if no data in range?
  if ( nrow(dat)==0 ) {
    if ( verb ) cat(paste("no data!\n"))
    plot(1,col=NA,axes=F, ylab=ylab, xlab=NA, ...)
    return()
  }

  ## TODO: generalize, account for smoothing!
  if ( missing(ylim) ) {
    if ( log=="y" ) { ## handle y-axis log ## TODO: better solution?
      tmp <- na.omit(dat[,3:ncol(dat)])
      tmp <- tmp[tmp>0]
      if ( length(tmp)>1 )
        ylim <- range(tmp)
      else ylim <- c(0,0)    
    }  else {
      ylim <- range(dat[,3:ncol(dat)],na.rm=TRUE)
    }
  }
  ## for blocks plotted in introns/scripts/chainCMResults.R (original use!)
  if ( !missing(ylim1) ) ylim[1] <- ylim1
  
  ## use same baseline for all data
  if ( length(baseline)==1 ) {
    baseline <- rep(baseline, ncol(dat)-2)
    ## force log baseline: use ylim[1]! ## TODO: inconsistent hack !?
    if ( log=="y" ) 
      baseline <- rep(ylim[1], ncol(dat)-2)
    names(baseline) <- colnames(dat)[3:ncol(dat)]
  }
  
  x <- dat[,"coor"]
  plot(range(x),ylim,col=NA,xlim=xlim,axes=FALSE,ylim=ylim,ylab=ylab,log=log,
       ...)
  ## draw polygons of data contigs
  ## TODO: avoid non verticallines!?
  for ( i in 3:ncol(dat) ) {
    ## get data and color
    id <- colnames(dat)[i]
    col <- colors[id]
    if ( names(dev.cur()) != "postscript" & shaded) {
      col.p <- paste(col,"22",sep="") ## shaded
    }else{ col.p <- col}
    y <- dat[,i]

    if ( !missing(filter) ) y <- filter(y,rep(1/filter,filter))

    ## handle 0 if log is requested?
    ## TODO: dirty hack!?
    if ( log=="y" ) { y[y==0] <- ylim[1] }
    
    ## draw one polygon for each contiguous data block
    y.p <- y[!is.na(y)]
    if ( length(y.p)==0 ) next
    x.p <- x[!is.na(y)]

    
    if ( lines ) { ## simple lines
      if ( smooth ) y.p <- smooth(y.p)
      lines(x.p, y.p, col=col)
    } else if ( blockwise ) { ## separate blocks
      fst <- 1
      blocks <- c(which(diff(x.p)>1),length(x.p))
      for ( bl in blocks ) {
        x.p1 <- c(x.p[fst:bl],x.p[bl],x.p[fst],x.p[fst])
        y.p1 <- c(y.p[fst:bl],rep(baseline[id],2),y.p[fst])
        polygon(x.p1,y.p1,col=col.p, border=col)
        fst <- bl+1
      }
    } else { ## one block
      if ( smooth ) y.p <- smooth(y.p)
      x.p <- c(x.p,x.p[length(x.p)],x.p[1],x.p[1])
      y.p <- c(y.p,rep(baseline[id],2),y.p[1])
      polygon(x.p,y.p,col=col.p, border=col)
    }
  }
  xrng <- diff(xlim)
  if ( axis1 )
    axis(1, at=pretty(c(xlim[1]-xrng/10,xlim[2]+xrng/10)))
  axis(2)
}

## plot features as little colored blocks (for large domain plots)
plotFeatureBlocks <- function(features, coors, types, columns=c(name="name",chr="chr",strand="strand",start="start",end="end",type="type",color="color"), border, ...) {
  
  chr <- coors[1]
  xlim <- sort(coors[2:3])

  ## cut to xlim
  coor <- cbind(as.numeric(features[,columns["start"]]),
                as.numeric(features[,columns["end"]]))
  
  ## find overlapping features
  lovl <- apply(coor,1,max) >= xlim[1] & apply(coor,1,max) <= xlim[2]
  rovl <- apply(coor,1,min) >= xlim[1] & apply(coor,1,min) <= xlim[2]
  insd <- lovl & rovl
  span <- apply(coor,1,min) <= xlim[1] & apply(coor,1,max) >= xlim[2]
  ovl <- ( lovl | rovl ) | span

  chrf <- as.numeric(features[,columns["chr"]])
  feat <- features[chrf == chr & ovl,, drop=FALSE]

  feat <- feat[order(feat[,columns["start"]]),]

  if ( missing(types) )
    types <- as.character(unique(feat[,columns["type"]]))
  
  plot(0,,col=NA,xlim=xlim,axes=FALSE, ylim=c(-1,1), ...)
  if ( nrow(feat)>0 )
    for ( i in 1:nrow(feat) ) {
      typ <- as.character(feat[i,columns["type"]])
      if ( !typ %in% types ) next
      col <- as.character(feat[i,columns["color"]])
      if ( missing(border) ) border <- col
      y <-  feat[i,columns["strand"]] 
      if ( is.na(y))y <- +1
      if ( y=="." ) y <- +1
      if ( y=="-" ) y <- -1
      if ( y=="+" ) y <- +1
      x <- feat[i,columns[c("start","end")]]
    #cat(paste(feat[i,"name"], x, y, col, "\n"))
      polygon(c(x,rev(x)),c(0,0,y,y),col=col, border=border)
    }
}

#' plot genomic features as arrows
#' TODO: replace by genomeBrowser functions
#' @export
plotFeatures <- function(features, coors, types, typord=FALSE, cuttypes=FALSE,
                         names=FALSE, legend=FALSE, xaxis=FALSE, ylab=NA,
                         columns=c(name="name",chr="chr",strand="strand",start="start",end="end",type="type",color="color"),line=-1,ycx=1) {

  chr <- as.character(coors[1])
  xlim <- sort(coors[2:3])

  ## cut to xlim
  coor <- cbind(as.numeric(features[,columns["start"]]),
                as.numeric(features[,columns["end"]]))
  ## find overlapping features
  lovl <- apply(coor,1,max) >= xlim[1] & apply(coor,1,max) <= xlim[2]
  rovl <- apply(coor,1,min) >= xlim[1] & apply(coor,1,min) <= xlim[2]
  insd <- lovl & rovl
  span <- apply(coor,1,min) <= xlim[1] & apply(coor,1,max) >= xlim[2]
  ovl <- ( lovl | rovl ) | span
  ## index featurse to determine where to plot names
  if ( names )
    features <- cbind(features, lovl=lovl, rovl=rovl, insd=insd, span=span)
  ## take only overlapping features
  ## to avoid factor confusion!
  chrs <- as.character(features[,columns["chr"]])
  feat <- features[chrs == chr & ovl,, drop=FALSE]
  coor <- cbind(as.numeric(feat[,columns["start"]]),
                as.numeric(feat[,columns["end"]]))
  ## order start/end by strand (arrow direction!)
  str <- as.character(feat[,columns["strand"]])
  ## TODO draw different arrow for strand=.
  coor[str==".",] <- t(apply(coor[str==".",,drop=FALSE],1,
                                       function(x) sort(x,decreasing=FALSE)))
  coor[str=="+"|str=="+1",] <- t(apply(coor[str=="+"|str=="+1",,drop=FALSE],1,
                                       function(x) sort(x,decreasing=FALSE)))
  coor[str=="-"|str=="-1",] <- t(apply(coor[str=="-"|str=="-1",,drop=FALSE],1,
                                       function(x) sort(x,decreasing=TRUE)))

  ## TODO: redirect to plotFeatureBlocks if too many features
  
  ## filter types 
  typey <- NULL
  if ( missing(types) ) {
    types <- unique(feat[,columns["type"]])
  } else if ( cuttypes ) {
    types <- types[types%in%feat[,columns["type"]]]
  }


  ## ylimits without typord
  ylim <- c(-.1,1.1)
  ## generate y-order and ylim, unless y is set by types
  ## TODO: generate a matrix of feature overlaps to select y-value and ylim
  if ( typord & (nrow(coor)>0 & length(types)>0) ) {
    offset <- 1/length(types)
    typey <- 1-offset*0:(length(types)-1)
    names(typey) <- types
    ylim <- c(min(typey)-offset, max(typey)+offset)
  }
  ## plot
  #old.par <- par(no.readonly = TRUE)
  #on.exit(par(old.par))
  plot(0,xlim=xlim,ylim=ylim,col=NA,axes=FALSE,ylab=ylab,xlab=NA)
  offset <- - 1/nrow(feat)
  y <- .5
  for ( i in order(rowMeans(coor)) ) {
    typ <- as.character(feat[i,columns["type"]])
    if ( !typ %in% types ) next
    yt <- ifelse(typord, typey[typ], y) 
    if ( columns["color"] %in% colnames(feat) )
      col <- as.character(feat[i,columns["color"]])
    else col <- 1
    
    x <- coor[i,]
    if ( x[1]!=x[2] )
      arrows(x0=x[1], y0=yt, col=col,y1=yt, x1=x[2], lwd=2, length=.1)
    points(x=x[1], y=yt, col=col, pch=3, lwd=2)
    if ( names ) {
      if ( feat[i,"insd"] ) x <- mean(x)
      else if ( feat[i,"span"] ) x <- mean(xlim)
      else if ( feat[i,"lovl"] ) x <- max(x)
      else if ( feat[i,"rovl"] ) x <- min(x)
      text(x=x, y=yt, labels=feat[i,columns["name"]],pos=3,col=col)
    }
    if ( typord ) next
    y <- y + offset
    if ( y > 0.9 & offset> 0 ) { offset <- -offset; y <- 1 }
    if ( y < 0.1 & offset< 0 ) { offset <- -offset; y <- 0 + offset/2 }
  }
  if ( typord & (nrow(coor)>0 & length(types)>0) ) 
    axis(2,at=typey,labels=names(typey),las=2,line=line,tcl=.3, mgp=c(2,.5,0),
         cex.axis=ycx)
  if ( xaxis ) axis(1,line=-1)

  ## return list of features plotted
  rownames(feat[feat[,columns["type"]] %in% types,])
}


## GENERAL UTILS

## push and pop functions,taken from
# http://www.johnmyleswhite.com/notebook/2009/12/07/implementing-push-and-pop-in-r/
# used in secondary structure and alignment parsing
push <- function(vec, item) {
  vec=substitute(vec)
  eval.parent(parse(text = paste(vec, ' <- c(', vec, ', ', item, ')', sep = '')), n = 1)
}
pop <- function(vec) {
  tmp <- vec[length(vec)]
  vec=substitute(vec)
  eval.parent(parse(text = paste(vec, ' <- ', vec, '[-length(', vec, ')]',
                      sep = '')),
              n = 1)
  tmp
}

### R2.14 function:
#regmatches <- function (x, m, invert = FALSE) 
#{
#    if (length(x) != length(m)) 
#        stop(gettextf("%s and %s must have the same length", 
#            sQuote("x"), sQuote("m")), domain = NA)
#    ili <- is.list(m)
#    useBytes <- if (ili) 
#        any(unlist(lapply(m, attr, "useBytes")))
#    else any(attr(m, "useBytes"))
#    if (useBytes) {
#        asc <- iconv(x, "latin1", "ASCII")
#        ind <- is.na(asc) | (asc != x)
#        if (any(ind)) 
#            Encoding(x[ind]) <- "bytes"
#    }
#    if (!ili && !invert) {
#        so <- m[ind <- (!is.na(m) & (m > -1L))]
#        eo <- so + attr(m, "match.length")[ind] - 1L
#        return(substring(x[ind], so, eo))
#    }
#    y <- if (invert) {
#        Map(function(u, so, ml) {
#            if ((n <- length(so)) == 1L) {
#                if (is.na(so)) 
#                  return(character())
#                else if (so == -1L) 
#                  return(u)
#            }
#            beg <- if (n > 1L) {
#                eo <- so + ml - 1L
#                if (any(eo[-n] >= so[-1L])) 
#                  stop(gettextf("need non-overlapping matches for %s", 
#                    sQuote("invert = TRUE")), domain = NA)
#                c(1L, eo + 1L)
#            }
#            else {
#                c(1L, so + ml)
#            }
#            end <- c(so - 1L, nchar(u))
#            substring(u, beg, end)
#        }, x, m, if (ili) 
#            lapply(m, attr, "match.length")
#        else attr(m, "match.length"), USE.NAMES = FALSE)
#    }
#    else {
#        Map(function(u, so, ml) {
#            if (length(so) == 1L) {
#                if (is.na(so) || (so == -1L)) 
#                  return(character())
#            }
#            substring(u, so, so + ml - 1L)
#        }, x, m, lapply(m, attr, "match.length"), USE.NAMES = FALSE)
#    }
#    names(y) <- names(x)
#    y
#}


## PLOT UTILITIES
#' Switch between plot devices
#' 
#' choose between plotting devices with same arguments
#' @param file.name file name without suffix (.png, etc)
#' @param type plot type: png, jpeg, eps, pdf, tiff or svg
#' @param width figure width in inches
#' @param height figure height in inches
#' @param res resolution in ppi (pixels per inch), only for 'png' and 'tiff'
#' @export
plotdev <- function(file.name="test", type="png", width=5, height=5, res=100) {
  file.name <- paste(file.name, type, sep=".")
  if ( type == "png" )
    grDevices::png(file.name, width=width, height=height, units="in", res=res)
  if ( type == "eps" )
    grDevices::postscript(file.name, width=height, height=width,paper="special",
                          horizontal = FALSE, onefile = FALSE)
  if ( type == "pdf" )
    grDevices::pdf(file.name, width=width, height=height)
  if ( type == "tiff" )
    grDevices::tiff(file.name, width=width, height=height, units="in", res=res)
  if ( type == "svg" )
    grDevices::svg(file.name, width=width, height=height)
  if ( type == "jpeg" )
    grDevices::jpeg(file.name, width=width, height=height, units="in", res=res)
}
#' converts an R matrix/data.frame to a latex table
#'
#' @param table an R matrix/data.frame to be converted to latex
#' @param tabalign latex field alignment keys, a string of characters
#' (r:right,l:left,c:center) of the same length as the table columns
#' @param tabpos latex table positioning string
#' @param row.names if TRUE, the table's row names will be used as first column
#' @param name if \code{row.names==TRUE} this will be used in the
#' header field's first column
#' @param caption latex table caption string
#' @param label latex table label
#' @export
tab2tex <- function(table, tabalign, tabpos, row.names=FALSE, name, caption, label) {
    col.num <- ncol(table) + sum(row.names)
    col.names <- colnames(table)
    if ( row.names ) col.names <- c(ifelse(missing(name),"",name),col.names)
    
    if ( missing(tabalign) )
      tabalign <- paste(rep("l",col.num),collapse="")
    
    tex <- paste("\\begin{table}",
                 ifelse(missing(tabpos),"\n",paste(tabpos,"\n")),
                 "\\begin{tabular}{",tabalign,"}\n","",
                 paste("\\bf", col.names, collapse=" & ")," \\\\\n",sep="  ")

    for ( i in 1:nrow(table) )
      {
        tex <- paste(tex, "      ",sep="")
        if ( row.names ) tex <- paste(tex, rownames(table)[i], " & ")
        for ( j in 1:ncol(table) )
          tex <- paste(tex, sub("_",".",as.character(table[i,j])),
                       ifelse(j==ncol(table)," \\\\\n"," & "),sep="")
    
      }
    tex <- paste(tex,"  \\end{tabular}\n",sep="")
    if ( !missing(caption) )
      tex <- paste(tex, "  \\caption[]{",caption,"}\n",sep="")
    if ( !missing(label) )
      tex <- paste(tex, "  \\label{",label,"}\n",sep="")
    tex <- paste(tex,"\\end{table}\n",sep="")

    ## replace > and <
    tex <- gsub(">", "$>$", tex)
    tex <- gsub("<", "$<$", tex)
    tex
  }

## from package colorRamps
table.ramp <- function (n, mid = 0.5, sill = 0.5, base = 1, height = 1) {
    x <- seq(0, 1, length.out = n)
    y <- rep(0, length(x))
    sill.min <- max(c(1, round((n - 1) * (mid - sill/2)) + 1))
    sill.max <- min(c(n, round((n - 1) * (mid + sill/2)) + 1))
    y[sill.min:sill.max] <- 1
    base.min <- round((n - 1) * (mid - base/2)) + 1
    base.max <- round((n - 1) * (mid + base/2)) + 1
    xi <- base.min:sill.min
    yi <- seq(0, 1, length.out = length(xi))
    i <- which(xi > 0 & xi <= n)
    y[xi[i]] <- yi[i]
    xi <- sill.max:base.max
    yi <- seq(1, 0, length.out = length(xi))
    i <- which(xi > 0 & xi <= n)
    y[xi[i]] <- yi[i]
    height * y
}
#' generate RGB color ramps, copied from package colorRamps
#' @param n number of colors to generate
#' @param red a length 3 vector with values `mid', `sill' and `base'
#' @param green same as `red'
#' @param blue same as `red'
#' @export
rgb.tables <- function (n, red = c(0.75, 0.25, 1), green = c(0.5, 0.25, 1), 
                        blue = c(0.25, 0.25, 1)) {
    rr <- do.call("table.ramp", as.list(c(n, red)))
    gr <- do.call("table.ramp", as.list(c(n, green)))
    br <- do.call("table.ramp", as.list(c(n, blue)))
    rgb(rr, gr, br)
}


